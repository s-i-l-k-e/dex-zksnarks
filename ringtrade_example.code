import "./decodeOrder.code"


def tupleForTokensWithValue(value):
  return value, value, value

def tupleForTokenPairsWithValue(value):
  return value, value, value, value, value, value

def findPairInTokenPairList(pairToken0Token1, pairToken0Token2, pairToken1Token0, pairToken1Token2, pairToken2Token0, pairToken2Token1, sourceToken, targetToken):
  pair = 0
  pair = if sourceToken == 0 then if targetToken == 1 then pairToken0Token1 else pair fi else pair fi
  pair = if sourceToken == 0 then if targetToken == 2 then pairToken0Token2 else pair fi else pair fi
  pair = if sourceToken == 1 then if targetToken == 0 then pairToken1Token0 else pair fi else pair fi
  pair = if sourceToken == 1 then if targetToken == 2 then pairToken1Token2 else pair fi else pair fi
  pair = if sourceToken == 2 then if targetToken == 0 then pairToken2Token0 else pair fi else pair fi
  pair = if sourceToken == 2 then if targetToken == 1 then pairToken2Token1 else pair fi else pair fi
  return pair

def priceFromTo(sourceToken, targetToken, priceToken1, priceToken2):
  refTokenPriceToUtxo = if sourceToken == 0 then 1000000000000000000 else 0 fi
  refTokenPriceToUtxo = refTokenPriceToUtxo + if sourceToken == 1 then priceToken1 else 0 fi
  refTokenPriceToUtxo = refTokenPriceToUtxo + if sourceToken == 2 then priceToken2 else 0 fi

  refTokenPriceToTarget = if targetToken == 0 then 1000000000000000000 else 0 fi
  refTokenPriceToTarget = refTokenPriceToTarget + if targetToken == 1 then priceToken1 else 0 fi
  refTokenPriceToTarget = refTokenPriceToTarget + if targetToken == 2 then priceToken2 else 0 fi

  return 1000000000000000000 * (refTokenPriceToTarget/refTokenPriceToUtxo)

def limitLessThanPrice(sourceToken, targetToken, limit, priceToken1, priceToken2):
  // Assuming limit is in sourceToken->targetToken and price_i in refToken->token_i
  // Because of arbitrage freeness the following statement should hold:
  // sourceToken->targetToken = sourceToken->refToken * refToken->targetToken = refToken->targetToken / refToken->sourceToken
  // Therefore we have to check that:
  // limit <= refToken->targetToken / refToken->sourceToken <==> refToken->targetToken / refToken->sourceToken > limit
  limitIsLessOrEqual = if priceFromTo(sourceToken, targetToken, priceToken1, priceToken2) < limit then 0 else 1 fi
  return limitIsLessOrEqual

def addSellVolumesForOrder(sellVolumeToken1, sellVolumeToken2, sellVolumeToken3, sourceToken, volume):
  updatedVolumeToken1 = sellVolumeToken1 + if sourceToken == 0 then volume else 0 fi
  updatedVolumeToken2 = sellVolumeToken2 + if sourceToken == 1 then volume else 0 fi
  updatedVolumeToken3 = sellVolumeToken3 + if sourceToken == 2 then volume else 0 fi
  return updatedVolumeToken1, updatedVolumeToken2, updatedVolumeToken3

def addBuyVolumesForOrder(buyVolumeToken1, buyVolumeToken2, buyVolumeToken3, sourceToken, volume, targetToken, priceToken1, priceToken2):
  buyVolume = volume * priceFromTo(sourceToken, targetToken, priceToken1, priceToken2) / 1000000000000000000 
  txBuyVolumeToken1 = buyVolumeToken1 + if targetToken == 0 then buyVolume else 0 fi
  txBuyVolumeToken2 = buyVolumeToken2 + if targetToken == 1 then buyVolume else 0 fi
  txBuyVolumeToken3 = buyVolumeToken3 + if targetToken == 2 then buyVolume else 0 fi
  return txBuyVolumeToken1, txBuyVolumeToken2, txBuyVolumeToken3

def updateHighestTouchedOrder(highestTouchedOrderToken0Token1, highestTouchedOrderToken0Token2, highestTouchedOrderToken1Token0, highestTouchedOrderToken1Token2, highestTouchedOrderToken2Token0, highestTouchedOrderToken2Token1, sourceToken, targetToken, limit, volume):

  highestTouchedOrder = findPairInTokenPairList(highestTouchedOrderToken0Token1, highestTouchedOrderToken0Token2, highestTouchedOrderToken1Token0, highestTouchedOrderToken1Token2, highestTouchedOrderToken2Token0, highestTouchedOrderToken2Token1, sourceToken, targetToken)

  shouldUpdate = if 0 < volume then 1 else 0 fi
  shouldUpdate = if highestTouchedOrder < limit then shouldUpdate else 0 fi

  highestTouchedOrderToken0Token1 = if shouldUpdate == 1 then if sourceToken == 0 then if targetToken == 1 then limit else highestTouchedOrderToken0Token1 fi else highestTouchedOrderToken0Token1 fi else highestTouchedOrderToken0Token1 fi
  highestTouchedOrderToken0Token2 = if shouldUpdate == 1 then if sourceToken == 0 then if targetToken == 2 then limit else highestTouchedOrderToken0Token2 fi else highestTouchedOrderToken0Token2 fi else highestTouchedOrderToken0Token2 fi
  highestTouchedOrderToken1Token0 = if shouldUpdate == 1 then if sourceToken == 1 then if targetToken == 0 then limit else highestTouchedOrderToken1Token0 fi else highestTouchedOrderToken1Token0 fi else highestTouchedOrderToken1Token0 fi
  highestTouchedOrderToken1Token2 = if shouldUpdate == 1 then if sourceToken == 1 then if targetToken == 2 then limit else highestTouchedOrderToken1Token2 fi else highestTouchedOrderToken1Token2 fi else highestTouchedOrderToken1Token2 fi
  highestTouchedOrderToken2Token0 = if shouldUpdate == 1 then if sourceToken == 2 then if targetToken == 0 then limit else highestTouchedOrderToken2Token0 fi else highestTouchedOrderToken2Token0 fi else highestTouchedOrderToken2Token0 fi
  highestTouchedOrderToken2Token1 = if shouldUpdate == 1 then if sourceToken == 2 then if targetToken == 1 then limit else highestTouchedOrderToken2Token1 fi else highestTouchedOrderToken2Token1 fi else highestTouchedOrderToken2Token1 fi

  return highestTouchedOrderToken0Token1, highestTouchedOrderToken0Token2, highestTouchedOrderToken1Token0, highestTouchedOrderToken1Token2, highestTouchedOrderToken2Token0, highestTouchedOrderToken2Token1

def verifyCompletelyFulfilledIfLimitLowerHighestTouchedOrder(highestTouchedOrderToken0Token1, highestTouchedOrderToken0Token2, highestTouchedOrderToken1Token0, highestTouchedOrderToken1Token2, highestTouchedOrderToken2Token0, highestTouchedOrderToken2Token1, sourceAmount, sourceToken, targetToken, limit, volume, priceToken1, priceToken2):

  highestTouchedOrder = findPairInTokenPairList(highestTouchedOrderToken0Token1, highestTouchedOrderToken0Token2, highestTouchedOrderToken1Token0, highestTouchedOrderToken1Token2, highestTouchedOrderToken2Token0, highestTouchedOrderToken2Token1, sourceToken, targetToken)

  // Due to rounding rounding (e.g. 3 WEI at price .5), we cannot always completely fulfill this order.
  // Therefore check that exchanging one more unit would have been larger than the source amount
  valid = if limit < highestTouchedOrder then if sourceAmount < volume + (priceFromTo(targetToken, sourceToken, priceToken1, priceToken2) / 1000000000000000000) then 1 else 0 fi else 1 fi
  return valid

def checkConstraints(amount1, sourceToken1, targetToken1, limit1, amount2, sourceToken2, targetToken2, limit2, amount3, sourceToken3, targetToken3, limit3, volume1, volume2, volume3, priceToken1, priceToken2):
  // volumes are not larger than in original offer
  valid = if amount1 < volume1 then 0 else 1 fi
  valid == 1
  valid = if amount2 < volume2 then 0 else 1 fi
  valid == 1
  valid = if amount3 < volume3 then 0 else 1 fi
  valid == 1

  // orders are only touched, if the limit price is below the calculated price:
  valid = if volume1 == 0 then 1 else limitLessThanPrice(sourceToken1, targetToken1, limit1, priceToken1, priceToken2) fi
  valid == 1
  valid = if volume2 == 0 then 1 else limitLessThanPrice(sourceToken2, targetToken2, limit2, priceToken1, priceToken2) fi
  valid == 1
  valid = if volume3 == 0 then 1 else limitLessThanPrice(sourceToken3, targetToken3, limit3, priceToken1, priceToken2) fi
  valid == 1

  // the amount of sell volume for a token equals its buy volume:
  buyVolumeToken1, buyVolumeToken2, buyVolumeToken3 = tupleForTokensWithValue(0)
  sellVolumeToken1, sellVolumeToken2, sellVolumeToken3 = tupleForTokensWithValue(0)

  buyVolumeToken1, buyVolumeToken2, buyVolumeToken3 = addBuyVolumesForOrder(buyVolumeToken1, buyVolumeToken2, buyVolumeToken3, sourceToken1, volume1, targetToken1, priceToken1, priceToken2)
  sellVolumeToken1, sellVolumeToken2, sellVolumeToken3 = addSellVolumesForOrder(sellVolumeToken1, sellVolumeToken2, sellVolumeToken3, sourceToken1, volume1)

  buyVolumeToken1, buyVolumeToken2, buyVolumeToken3 = addBuyVolumesForOrder(buyVolumeToken1, buyVolumeToken2, buyVolumeToken3, sourceToken2, volume2, targetToken2, priceToken1, priceToken2)
  sellVolumeToken1, sellVolumeToken2, sellVolumeToken3 = addSellVolumesForOrder(sellVolumeToken1, sellVolumeToken2, sellVolumeToken3, sourceToken2, volume2)

  buyVolumeToken1, buyVolumeToken2, buyVolumeToken3 = addBuyVolumesForOrder(buyVolumeToken1, buyVolumeToken2, buyVolumeToken3, sourceToken3, volume3, targetToken3, priceToken1, priceToken2)
  sellVolumeToken1, sellVolumeToken2, sellVolumeToken3 = addSellVolumesForOrder(sellVolumeToken1, sellVolumeToken2, sellVolumeToken3, sourceToken3, volume3)

  buyVolumeToken1 == sellVolumeToken1
  buyVolumeToken2 == sellVolumeToken2
  buyVolumeToken3 == sellVolumeToken3

  // If an order σ ∈ Oi→j with a limit price p has a positive trading volume, then every order in Oi→j with a lower limit price should be completely fulfilled.
  highestTouchedOrderToken0Token1, highestTouchedOrderToken0Token2, highestTouchedOrderToken1Token0, highestTouchedOrderToken1Token2, highestTouchedOrderToken2Token0, highestTouchedOrderToken2Token1 = tupleForTokenPairsWithValue(0)
  highestTouchedOrderToken0Token1, highestTouchedOrderToken0Token2, highestTouchedOrderToken1Token0, highestTouchedOrderToken1Token2, highestTouchedOrderToken2Token0, highestTouchedOrderToken2Token1 = updateHighestTouchedOrder(highestTouchedOrderToken0Token1, highestTouchedOrderToken0Token2, highestTouchedOrderToken1Token0, highestTouchedOrderToken1Token2, highestTouchedOrderToken2Token0, highestTouchedOrderToken2Token1, sourceToken1, targetToken1, limit1, volume1)
  highestTouchedOrderToken0Token1, highestTouchedOrderToken0Token2, highestTouchedOrderToken1Token0, highestTouchedOrderToken1Token2, highestTouchedOrderToken2Token0, highestTouchedOrderToken2Token1 = updateHighestTouchedOrder(highestTouchedOrderToken0Token1, highestTouchedOrderToken0Token2, highestTouchedOrderToken1Token0, highestTouchedOrderToken1Token2, highestTouchedOrderToken2Token0, highestTouchedOrderToken2Token1, sourceToken2, targetToken2, limit2, volume2)
  highestTouchedOrderToken0Token1, highestTouchedOrderToken0Token2, highestTouchedOrderToken1Token0, highestTouchedOrderToken1Token2, highestTouchedOrderToken2Token0, highestTouchedOrderToken2Token1 = updateHighestTouchedOrder(highestTouchedOrderToken0Token1, highestTouchedOrderToken0Token2, highestTouchedOrderToken1Token0, highestTouchedOrderToken1Token2, highestTouchedOrderToken2Token0, highestTouchedOrderToken2Token1, sourceToken3, targetToken3, limit3, volume3)

  valid = verifyCompletelyFulfilledIfLimitLowerHighestTouchedOrder(highestTouchedOrderToken0Token1, highestTouchedOrderToken0Token2, highestTouchedOrderToken1Token0, highestTouchedOrderToken1Token2, highestTouchedOrderToken2Token0, highestTouchedOrderToken2Token1, amount1, sourceToken1, targetToken1, limit1, volume1, priceToken1, priceToken2)
  valid == 1
  valid = verifyCompletelyFulfilledIfLimitLowerHighestTouchedOrder(highestTouchedOrderToken0Token1, highestTouchedOrderToken0Token2, highestTouchedOrderToken1Token0, highestTouchedOrderToken1Token2, highestTouchedOrderToken2Token0, highestTouchedOrderToken2Token1, amount2, sourceToken2, targetToken2, limit2, volume2, priceToken1, priceToken2)
  valid == 1
  valid = verifyCompletelyFulfilledIfLimitLowerHighestTouchedOrder(highestTouchedOrderToken0Token1, highestTouchedOrderToken0Token2, highestTouchedOrderToken1Token0, highestTouchedOrderToken1Token2, highestTouchedOrderToken2Token0, highestTouchedOrderToken2Token1, amount3, sourceToken3, targetToken3, limit3, volume3, priceToken1, priceToken2)
  valid == 1

  return 1 // Could return total volume to maximize for

def main(encodedOrder1, encodedOrder2, encodedOrder3, bitmapOrder1, bitmapOrder2, bitmapOrder3, volume1, volume2, volume3, priceToken1, priceToken2):
  // Remove orders that are not double signed
  encodedOrder1 = if bitmapOrder1 == 1 then encodedOrder1 else 0 fi
  encodedOrder2 = if bitmapOrder2 == 1 then encodedOrder2 else 0 fi
  encodedOrder3 = if bitmapOrder3 == 1 then encodedOrder3 else 0 fi

  // Decode orders
  amount1, sourceToken1, targetToken1, limit1 = decodeOrder(encodedOrder1)
  amount2, sourceToken2, targetToken2, limit2 = decodeOrder(encodedOrder2)
  amount3, sourceToken3, targetToken3, limit3 = decodeOrder(encodedOrder3)

  return checkConstraints(amount1, sourceToken1, targetToken1, limit1, amount2, sourceToken2, targetToken2, limit2, amount3, sourceToken3, targetToken3, limit3, volume1, volume2, volume3, priceToken1, priceToken2)